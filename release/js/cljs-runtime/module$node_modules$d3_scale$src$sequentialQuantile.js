shadow$provide.module$node_modules$d3_scale$src$sequentialQuantile=function(global,require,module,exports){function sequentialQuantile(){function scale(x){if(null!=x&&!isNaN(x=+x))return interpolator(((0,_d3Array.bisect)(domain,x,1)-1)/(domain.length-1))}var domain=[],interpolator=_continuous.identity;scale.domain=function(_){if(!arguments.length)return domain.slice();domain=[];var _iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=_[Symbol.iterator](),_step;!(_iteratorNormalCompletion=
(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var d=_step.value;null==d||isNaN(d=+d)||domain.push(d)}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{if(!_iteratorNormalCompletion&&null!=_iterator["return"])_iterator["return"]()}finally{if(_didIteratorError)throw _iteratorError;}}domain.sort(_d3Array.ascending);return scale};scale.interpolator=function(_){return arguments.length?(interpolator=_,scale):interpolator};scale.range=function(){return domain.map(function(d,
i){return interpolator(i/(domain.length-1))})};scale.quantiles=function(n){return Array.from({length:n+1},function(_,i){return(0,_d3Array.quantile)(domain,i/n)})};scale.copy=function(){return sequentialQuantile(interpolator).domain(domain)};return _init.initInterpolator.apply(scale,arguments)}Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=sequentialQuantile;var _d3Array=require("module$node_modules$d3_array$src$index"),_continuous=require("module$node_modules$d3_scale$src$continuous"),
_init=require("module$node_modules$d3_scale$src$init")}
//# sourceMappingURL=module$node_modules$d3_scale$src$sequentialQuantile.js.map

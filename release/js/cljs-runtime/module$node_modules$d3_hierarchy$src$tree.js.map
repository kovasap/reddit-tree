{
"version":3,
"file":"module$node_modules$d3_hierarchy$src$tree.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/d3-hierarchy/src/tree.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$d3_hierarchy$src$tree\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = _default;\n\nvar _index = require(\"./hierarchy/index.js\");\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n} // function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\n\n\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n} // This function works analogously to nextLeft.\n\n\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n} // Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\n\n\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n} // All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\n\n\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n} // If vi-\u2019s ancestor is a sibling of v, returns vi-\u2019s ancestor. Otherwise,\n// returns the specified (default) ancestor.\n\n\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n\n  this.a = this; // ancestor\n\n  this.z = 0; // prelim\n\n  this.m = 0; // mod\n\n  this.c = 0; // change\n\n  this.s = 0; // shift\n\n  this.t = null; // thread\n\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(_index.Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n} // Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\n\n\nfunction _default() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root); // Compute the layout using Buchheim et al.\u2019s algorithm.\n\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk); // If a fixed node size is specified, scale x and y.\n\n    if (nodeSize) root.eachBefore(sizeNode); // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n        var left = root,\n            right = root,\n            bottom = root;\n        root.eachBefore(function (node) {\n          if (node.x < left.x) left = node;\n          if (node.x > right.x) right = node;\n          if (node.depth > bottom.depth) bottom = node;\n        });\n        var s = left === right ? 1 : separation(left, right) / 2,\n            tx = s - left.x,\n            kx = dx / (right.x + s + tx),\n            ky = dy / (bottom.depth || 1);\n        root.eachBefore(function (node) {\n          node.x = (node.x + tx) * kx;\n          node.y = node.depth * ky;\n        });\n      }\n    return root;\n  } // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n\n\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  } // Computes all real x-coordinates by summing up the modifiers recursively.\n\n\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  } // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n\n\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function (x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function (x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];\n  };\n\n  tree.nodeSize = function (x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;\n  };\n\n  return tree;\n}\n};"],
"names":["shadow$provide","global","require","module","exports","defaultSeparation","a","b","parent","nextLeft","v","children","t","nextRight","length","TreeNode","node","i","_","A","s","c","m","z","treeRoot","root","tree","nodes","child","pop","Array","n","push","Object","defineProperty","value","_default","eachAfter","firstWalk","eachBefore","secondWalk","nodeSize","sizeNode","left","right","bottom","x","depth","separation","tx","kx","dx","ky","dy","y","siblings","w","shift","change","midpoint","vop","vip","vom","sip","sop","sim","vim","som","ancestor","wp","wm","tree.separation","arguments","size","tree.size","tree.nodeSize","_index","prototype","create","Node"]
}
